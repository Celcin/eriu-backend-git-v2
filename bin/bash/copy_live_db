#!/bin/bash
#===============================================================================
# db-sync.sh - Remote Database to Docker Container Sync Tool
# Supports MySQL and PostgreSQL with optional SSH tunneling and entity generation
# For Symfony 8 projects with Doctrine ORM 3.x
#===============================================================================
set -euo pipefail

#===============================================================================
# Configuration (override via command line or environment variables)
#===============================================================================
DB_ENGINE="${DB_ENGINE:-mysql}"              # mysql or pgsql
SOURCE_HOST="${SOURCE_HOST:-localhost}"
SOURCE_PORT="${SOURCE_PORT:-}"               # Auto-set based on engine if empty
SOURCE_USER="${SOURCE_USER:-root}"
SOURCE_PASSWORD="${SOURCE_PASSWORD:-}"
SOURCE_DATABASE="${SOURCE_DATABASE:-}"

DOCKER_CONTAINER="${DOCKER_CONTAINER:-}"
DOCKER_USER="${DOCKER_USER:-root}"
DOCKER_PASSWORD="${DOCKER_PASSWORD:-}"
DOCKER_DATABASE="${DOCKER_DATABASE:-}"

# SSH Tunnel settings
USE_SSH_TUNNEL="${USE_SSH_TUNNEL:-false}"
SSH_HOST="${SSH_HOST:-}"
SSH_USER="${SSH_USER:-}"
SSH_KEY="${SSH_KEY:-~/.ssh/id_rsa}"
SSH_PORT="${SSH_PORT:-22}"
LOCAL_TUNNEL_PORT="${LOCAL_TUNNEL_PORT:-}"   # Auto-assigned if empty

# Options
GENERATE_ENTITIES="${GENERATE_ENTITIES:-false}"
USE_COMPRESSION="${USE_COMPRESSION:-false}"
SHOW_PROGRESS="${SHOW_PROGRESS:-false}"
VERBOSE="${VERBOSE:-false}"
DRY_RUN="${DRY_RUN:-false}"

#===============================================================================
# Internal variables
#===============================================================================
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
SSH_SOCKET=""
EFFECTIVE_HOST=""
EFFECTIVE_PORT=""
CLEANUP_DONE=false

#===============================================================================
# Colors and logging
#===============================================================================
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log() { echo -e "${BLUE}[$(date '+%H:%M:%S')]${NC} $*"; }
log_success() { echo -e "${GREEN}[$(date '+%H:%M:%S')] ✓${NC} $*"; }
log_warn() { echo -e "${YELLOW}[$(date '+%H:%M:%S')] ⚠${NC} $*" >&2; }
log_error() { echo -e "${RED}[$(date '+%H:%M:%S')] ✗${NC} $*" >&2; }
log_verbose() { [[ "$VERBOSE" == "true" ]] && log "$*" || true; }

#===============================================================================
# Usage
#===============================================================================
usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS]

Remote database to Docker container sync tool for Symfony 8 projects.
Supports MySQL and PostgreSQL with SSH tunneling and Doctrine entity generation.

Required:
  --source-host HOST        Remote database host (or tunnel destination)
  --source-user USER        Remote database username
  --source-database DB      Remote database name
  --container NAME          Docker container name running the database

Database options:
  --engine ENGINE           Database engine: mysql or pgsql (default: mysql)
  --source-port PORT        Remote database port (default: 3306/5432)
  --source-password PASS    Remote database password (or set SOURCE_PASSWORD env)
  --docker-user USER        Docker container DB user (default: root)
  --docker-password PASS    Docker container DB password (or set DOCKER_PASSWORD env)
  --docker-database DB      Docker database name (default: same as source)

SSH tunnel options:
  --ssh-tunnel              Enable SSH tunneling
  --ssh-host HOST           SSH bastion/jump host
  --ssh-user USER           SSH username
  --ssh-key PATH            SSH private key path (default: ~/.ssh/id_rsa)
  --ssh-port PORT           SSH port (default: 22)
  --local-port PORT         Local tunnel port (default: auto-assigned)

Performance options:
  --compress                Enable gzip compression (recommended for large DBs)
  --progress                Show transfer progress (requires 'pv' command)

Symfony integration:
  --generate-entities       Run Doctrine entity generation after import

Other options:
  --verbose                 Show detailed output
  --dry-run                 Show commands without executing
  --help                    Show this help message

Examples:
  # Direct MySQL connection
  $(basename "$0") --engine mysql --source-host db.example.com \\
      --source-user admin --source-database myapp \\
      --container mysql_container

  # PostgreSQL with SSH tunnel
  $(basename "$0") --engine pgsql --ssh-tunnel --ssh-host bastion.example.com \\
      --ssh-user ec2-user --source-host rds.internal \\
      --source-user postgres --source-database myapp \\
      --container postgres_container --generate-entities

  # Large database with compression and progress
  $(basename "$0") --engine mysql --source-host db.example.com \\
      --source-user admin --source-database bigdb \\
      --container mysql_container --compress --progress

EOF
    exit 0
}

#===============================================================================
# Argument parsing
#===============================================================================
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --engine) DB_ENGINE="$2"; shift 2 ;;
            --source-host) SOURCE_HOST="$2"; shift 2 ;;
            --source-port) SOURCE_PORT="$2"; shift 2 ;;
            --source-user) SOURCE_USER="$2"; shift 2 ;;
            --source-password) SOURCE_PASSWORD="$2"; shift 2 ;;
            --source-database) SOURCE_DATABASE="$2"; shift 2 ;;
            --container) DOCKER_CONTAINER="$2"; shift 2 ;;
            --docker-user) DOCKER_USER="$2"; shift 2 ;;
            --docker-password) DOCKER_PASSWORD="$2"; shift 2 ;;
            --docker-database) DOCKER_DATABASE="$2"; shift 2 ;;
            --ssh-tunnel) USE_SSH_TUNNEL="true"; shift ;;
            --ssh-host) SSH_HOST="$2"; shift 2 ;;
            --ssh-user) SSH_USER="$2"; shift 2 ;;
            --ssh-key) SSH_KEY="$2"; shift 2 ;;
            --ssh-port) SSH_PORT="$2"; shift 2 ;;
            --local-port) LOCAL_TUNNEL_PORT="$2"; shift 2 ;;
            --generate-entities) GENERATE_ENTITIES="true"; shift ;;
            --compress) USE_COMPRESSION="true"; shift ;;
            --progress) SHOW_PROGRESS="true"; shift ;;
            --verbose) VERBOSE="true"; shift ;;
            --dry-run) DRY_RUN="true"; shift ;;
            --help|-h) usage ;;
            *) log_error "Unknown option: $1"; usage ;;
        esac
    done
}

#===============================================================================
# Validation
#===============================================================================
validate_requirements() {
    local missing=()
    
    # Check required parameters
    [[ -z "$SOURCE_DATABASE" ]] && missing+=("--source-database")
    [[ -z "$DOCKER_CONTAINER" ]] && missing+=("--container")
    
    if [[ "$USE_SSH_TUNNEL" == "true" ]]; then
        [[ -z "$SSH_HOST" ]] && missing+=("--ssh-host (required with --ssh-tunnel)")
        [[ -z "$SSH_USER" ]] && missing+=("--ssh-user (required with --ssh-tunnel)")
    fi
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing required parameters: ${missing[*]}"
        echo ""
        usage
    fi
    
    # Set defaults based on engine
    if [[ -z "$SOURCE_PORT" ]]; then
        case "$DB_ENGINE" in
            mysql) SOURCE_PORT=3306 ;;
            pgsql) SOURCE_PORT=5432 ;;
        esac
    fi
    
    [[ -z "$DOCKER_DATABASE" ]] && DOCKER_DATABASE="$SOURCE_DATABASE"
    
    if [[ -z "$LOCAL_TUNNEL_PORT" && "$USE_SSH_TUNNEL" == "true" ]]; then
        case "$DB_ENGINE" in
            mysql) LOCAL_TUNNEL_PORT=33060 ;;
            pgsql) LOCAL_TUNNEL_PORT=54320 ;;
        esac
    fi
    
    # Validate engine
    if [[ ! "$DB_ENGINE" =~ ^(mysql|pgsql)$ ]]; then
        log_error "Invalid engine: $DB_ENGINE. Must be 'mysql' or 'pgsql'"
        exit 1
    fi
    
    # Check required commands
    local cmds=("docker")
    case "$DB_ENGINE" in
        mysql) cmds+=("mysqldump" "mysql") ;;
        pgsql) cmds+=("pg_dump" "psql") ;;
    esac
    [[ "$USE_SSH_TUNNEL" == "true" ]] && cmds+=("ssh")
    [[ "$SHOW_PROGRESS" == "true" ]] && cmds+=("pv")
    [[ "$USE_COMPRESSION" == "true" ]] && cmds+=("gzip" "gunzip")
    
    for cmd in "${cmds[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            log_error "Required command not found: $cmd"
            exit 1
        fi
    done
    
    # Check Docker container exists
    if ! docker ps --format '{{.Names}}' | grep -q "^${DOCKER_CONTAINER}$"; then
        log_error "Docker container not running: $DOCKER_CONTAINER"
        log "Running containers:"
        docker ps --format '  {{.Names}}'
        exit 1
    fi
    
    # WSL2 check for line endings
    if [[ -f /proc/version ]] && grep -qi microsoft /proc/version; then
        log_verbose "WSL2 environment detected"
        if file "${BASH_SOURCE[0]}" | grep -q CRLF; then
            log_warn "Script has Windows line endings (CRLF). Run: dos2unix ${BASH_SOURCE[0]}"
        fi
    fi
}

#===============================================================================
# Cleanup handler
#===============================================================================
cleanup() {
    [[ "$CLEANUP_DONE" == "true" ]] && return
    CLEANUP_DONE=true
    
    log_verbose "Running cleanup..."
    
    # Close SSH tunnel if active
    if [[ -n "$SSH_SOCKET" && -S "$SSH_SOCKET" ]]; then
        log_verbose "Closing SSH tunnel..."
        ssh -S "$SSH_SOCKET" -O exit "${SSH_USER}@${SSH_HOST}" 2>/dev/null || true
        rm -f "$SSH_SOCKET" 2>/dev/null || true
    fi
    
    log_verbose "Cleanup complete"
}

#===============================================================================
# SSH Tunnel management
#===============================================================================
start_ssh_tunnel() {
    log "Starting SSH tunnel to ${SSH_HOST}..."
    
    SSH_SOCKET=$(mktemp -u /tmp/db-sync-ssh-XXXXXX)
    
    local ssh_cmd=(
        ssh -M -S "$SSH_SOCKET"
        -i "$SSH_KEY"
        -p "$SSH_PORT"
        -fNT
        -o ExitOnForwardFailure=yes
        -o StrictHostKeyChecking=accept-new
        -o ServerAliveInterval=30
        -o ServerAliveCountMax=3
        -o ConnectTimeout=15
        -o BatchMode=yes
        -L "${LOCAL_TUNNEL_PORT}:${SOURCE_HOST}:${SOURCE_PORT}"
        "${SSH_USER}@${SSH_HOST}"
    )
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "[DRY RUN] ${ssh_cmd[*]}"
        return 0
    fi
    
    if ! "${ssh_cmd[@]}"; then
        log_error "Failed to establish SSH tunnel"
        return 1
    fi
    
    # Verify tunnel
    if ! ssh -S "$SSH_SOCKET" -O check "${SSH_USER}@${SSH_HOST}" 2>/dev/null; then
        log_error "SSH tunnel verification failed"
        return 1
    fi
    
    # Wait for port
    local attempts=0
    while ! nc -z localhost "$LOCAL_TUNNEL_PORT" 2>/dev/null; do
        ((attempts++))
        if [[ $attempts -ge 30 ]]; then
            log_error "Timeout waiting for tunnel port $LOCAL_TUNNEL_PORT"
            return 1
        fi
        sleep 1
    done
    
    EFFECTIVE_HOST="127.0.0.1"
    EFFECTIVE_PORT="$LOCAL_TUNNEL_PORT"
    
    log_success "SSH tunnel established on localhost:${LOCAL_TUNNEL_PORT}"
}

#===============================================================================
# Database operations
#===============================================================================
test_source_connection() {
    log "Testing source database connection..."
    
    case "$DB_ENGINE" in
        mysql)
            local test_cmd="mysql -h '$EFFECTIVE_HOST' -P '$EFFECTIVE_PORT' -u '$SOURCE_USER'"
            [[ -n "$SOURCE_PASSWORD" ]] && test_cmd+=" -p'$SOURCE_PASSWORD'"
            test_cmd+=" --connect-timeout=10 -e 'SELECT 1' >/dev/null 2>&1"
            
            if [[ "$DRY_RUN" == "true" ]]; then
                log "[DRY RUN] Testing MySQL connection"
                return 0
            fi
            
            if ! eval "$test_cmd"; then
                log_error "Cannot connect to source MySQL database"
                return 1
            fi
            ;;
        pgsql)
            if [[ "$DRY_RUN" == "true" ]]; then
                log "[DRY RUN] Testing PostgreSQL connection"
                return 0
            fi
            
            if ! PGPASSWORD="$SOURCE_PASSWORD" PGCONNECT_TIMEOUT=10 \
                psql -h "$EFFECTIVE_HOST" -p "$EFFECTIVE_PORT" \
                -U "$SOURCE_USER" -d "$SOURCE_DATABASE" \
                -c 'SELECT 1' >/dev/null 2>&1; then
                log_error "Cannot connect to source PostgreSQL database"
                return 1
            fi
            ;;
    esac
    
    log_success "Source database connection OK"
}

test_docker_connection() {
    log "Testing Docker container database..."
    
    case "$DB_ENGINE" in
        mysql)
            local test_cmd="docker exec $DOCKER_CONTAINER mysql -u '$DOCKER_USER'"
            [[ -n "$DOCKER_PASSWORD" ]] && test_cmd+=" -p'$DOCKER_PASSWORD'"
            test_cmd+=" -e 'SELECT 1' >/dev/null 2>&1"
            
            if [[ "$DRY_RUN" == "true" ]]; then
                log "[DRY RUN] Testing Docker MySQL"
                return 0
            fi
            
            if ! eval "$test_cmd"; then
                log_error "Cannot connect to Docker MySQL container"
                return 1
            fi
            ;;
        pgsql)
            if [[ "$DRY_RUN" == "true" ]]; then
                log "[DRY RUN] Testing Docker PostgreSQL"
                return 0
            fi
            
            if ! docker exec -e PGPASSWORD="$DOCKER_PASSWORD" "$DOCKER_CONTAINER" \
                psql -U "$DOCKER_USER" -d postgres -c 'SELECT 1' >/dev/null 2>&1; then
                log_error "Cannot connect to Docker PostgreSQL container"
                return 1
            fi
            ;;
    esac
    
    log_success "Docker container database OK"
}

create_docker_database() {
    log "Ensuring target database exists: $DOCKER_DATABASE"
    
    case "$DB_ENGINE" in
        mysql)
            local create_cmd="docker exec $DOCKER_CONTAINER mysql -u '$DOCKER_USER'"
            [[ -n "$DOCKER_PASSWORD" ]] && create_cmd+=" -p'$DOCKER_PASSWORD'"
            create_cmd+=" -e 'CREATE DATABASE IF NOT EXISTS \`$DOCKER_DATABASE\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci'"
            
            if [[ "$DRY_RUN" == "true" ]]; then
                log "[DRY RUN] $create_cmd"
                return 0
            fi
            
            eval "$create_cmd"
            ;;
        pgsql)
            if [[ "$DRY_RUN" == "true" ]]; then
                log "[DRY RUN] Creating PostgreSQL database"
                return 0
            fi
            
            # Check if database exists
            if ! docker exec -e PGPASSWORD="$DOCKER_PASSWORD" "$DOCKER_CONTAINER" \
                psql -U "$DOCKER_USER" -lqt | cut -d \| -f 1 | grep -qw "$DOCKER_DATABASE"; then
                docker exec -e PGPASSWORD="$DOCKER_PASSWORD" "$DOCKER_CONTAINER" \
                    psql -U "$DOCKER_USER" -c "CREATE DATABASE \"$DOCKER_DATABASE\""
            fi
            ;;
    esac
    
    log_success "Target database ready"
}

run_sync() {
    log "Starting database sync: $SOURCE_DATABASE -> $DOCKER_DATABASE"
    log "Engine: $DB_ENGINE | Compression: $USE_COMPRESSION | Progress: $SHOW_PROGRESS"
    
    local start_time=$(date +%s)
    
    case "$DB_ENGINE" in
        mysql) run_mysql_sync ;;
        pgsql) run_pgsql_sync ;;
    esac
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    log_success "Sync completed in ${duration}s"
}

run_mysql_sync() {
    # Build mysqldump command
    local dump_cmd="mysqldump"
    dump_cmd+=" -h '$EFFECTIVE_HOST' -P '$EFFECTIVE_PORT'"
    dump_cmd+=" -u '$SOURCE_USER'"
    [[ -n "$SOURCE_PASSWORD" ]] && dump_cmd+=" -p'$SOURCE_PASSWORD'"
    dump_cmd+=" --single-transaction"
    dump_cmd+=" --quick"
    dump_cmd+=" --routines"
    dump_cmd+=" --triggers"
    dump_cmd+=" --events"
    dump_cmd+=" --hex-blob"                    # Critical for binary data
    dump_cmd+=" --set-gtid-purged=OFF"         # Avoid GTID issues
    dump_cmd+=" --default-character-set=utf8mb4"
    dump_cmd+=" --column-statistics=0"         # MySQL 8 client -> MySQL 5 server
    dump_cmd+=" '$SOURCE_DATABASE'"
    
    # Build import command
    local import_cmd="docker exec -i"
    [[ -n "$DOCKER_PASSWORD" ]] && import_cmd+=" -e MYSQL_PWD='$DOCKER_PASSWORD'"
    import_cmd+=" $DOCKER_CONTAINER mysql"
    import_cmd+=" --max-allowed-packet=256M"
    import_cmd+=" --default-character-set=utf8mb4"
    import_cmd+=" --init-command='SET FOREIGN_KEY_CHECKS=0'"
    import_cmd+=" -u '$DOCKER_USER'"
    import_cmd+=" '$DOCKER_DATABASE'"
    
    # Build full pipeline
    local pipeline="$dump_cmd"
    
    if [[ "$SHOW_PROGRESS" == "true" ]]; then
        pipeline+=" | pv -W"
    fi
    
    if [[ "$USE_COMPRESSION" == "true" ]]; then
        pipeline+=" | gzip"
        import_cmd="docker exec -i $DOCKER_CONTAINER sh -c 'gunzip | mysql"
        import_cmd+=" --max-allowed-packet=256M"
        import_cmd+=" --default-character-set=utf8mb4"
        [[ -n "$DOCKER_PASSWORD" ]] && import_cmd+=" -p\"$DOCKER_PASSWORD\""
        import_cmd+=" -u $DOCKER_USER $DOCKER_DATABASE'"
    fi
    
    pipeline+=" | $import_cmd"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "[DRY RUN] Pipeline:"
        echo "$pipeline" | sed 's/-p[^ ]* /-p****** /g'
        return 0
    fi
    
    log_verbose "Executing sync pipeline..."
    eval "$pipeline"
}

run_pgsql_sync() {
    # Build pg_dump command
    local dump_cmd="PGPASSWORD='$SOURCE_PASSWORD' pg_dump"
    dump_cmd+=" -h '$EFFECTIVE_HOST' -p '$EFFECTIVE_PORT'"
    dump_cmd+=" -U '$SOURCE_USER'"
    dump_cmd+=" --no-owner"
    dump_cmd+=" --no-acl"
    dump_cmd+=" --clean"
    dump_cmd+=" --if-exists"
    dump_cmd+=" '$SOURCE_DATABASE'"
    
    # Build import command
    local import_cmd="docker exec -i"
    [[ -n "$DOCKER_PASSWORD" ]] && import_cmd+=" -e PGPASSWORD='$DOCKER_PASSWORD'"
    import_cmd+=" $DOCKER_CONTAINER psql"
    import_cmd+=" -U '$DOCKER_USER'"
    import_cmd+=" -d '$DOCKER_DATABASE'"
    import_cmd+=" --set ON_ERROR_STOP=off"     # Continue on non-critical errors
    
    # Build full pipeline
    local pipeline="$dump_cmd"
    
    if [[ "$SHOW_PROGRESS" == "true" ]]; then
        pipeline+=" | pv -W"
    fi
    
    if [[ "$USE_COMPRESSION" == "true" ]]; then
        pipeline+=" | gzip"
        import_cmd="docker exec -i"
        [[ -n "$DOCKER_PASSWORD" ]] && import_cmd+=" -e PGPASSWORD='$DOCKER_PASSWORD'"
        import_cmd+=" $DOCKER_CONTAINER sh -c 'gunzip | psql -U $DOCKER_USER -d $DOCKER_DATABASE'"
    fi
    
    pipeline+=" | $import_cmd"
    
    if [[ "$DRY_RUN" == "true" ]]; then
        log "[DRY RUN] Pipeline:"
        echo "$pipeline" | sed 's/PGPASSWORD=[^ ]*/PGPASSWORD=******/g'
        return 0
    fi
    
    log_verbose "Executing sync pipeline..."
    eval "$pipeline"
}

#===============================================================================
# Doctrine entity generation
#===============================================================================
generate_entities() {
    log "Generating Doctrine entities from imported database..."
    
    cd "$PROJECT_ROOT"
    
    # Check for siburuxue/doctrine-helper (modern replacement for doctrine:mapping:import)
    if php bin/console list 2>/dev/null | grep -q "doctrine-helper:mapping:import"; then
        log "Using doctrine-helper:mapping:import..."
        
        if [[ "$DRY_RUN" == "true" ]]; then
            log "[DRY RUN] php bin/console doctrine-helper:mapping:import App\\\\Entity attribute --path=src/Entity --ucfirst=true"
            log "[DRY RUN] php bin/console make:entity --regenerate App"
            return 0
        fi
        
        php bin/console doctrine-helper:mapping:import 'App\Entity' attribute \
            --path=src/Entity \
            --ucfirst=true
        
        log_success "Entities generated in src/Entity/"
        
        # Regenerate getters/setters
        log "Regenerating entity methods..."
        php bin/console make:entity --regenerate App --no-interaction
        
    else
        log_warn "doctrine-helper not installed. Install with:"
        log_warn "  composer require siburuxue/doctrine-helper"
        log_warn ""
        log_warn "Alternative: Manual entity creation workflow:"
        log_warn "  1. php bin/console doctrine:mapping:info"
        log_warn "  2. php bin/console make:entity EntityName"
        log_warn "  3. Add properties matching database columns"
        return 1
    fi
    
    # Validate schema
    log "Validating Doctrine mapping..."
    if php bin/console doctrine:schema:validate --skip-sync 2>/dev/null; then
        log_success "Doctrine mapping validation passed"
    else
        log_warn "Schema validation has warnings (this is often expected after import)"
    fi
    
    log_success "Entity generation complete"
    log "Next steps:"
    log "  1. Review generated entities in src/Entity/"
    log "  2. Add inverse relationships (OneToMany) manually"
    log "  3. Add cascade operations and lifecycle callbacks as needed"
    log "  4. Run: php bin/console doctrine:schema:validate"
}

#===============================================================================
# Main
#===============================================================================
main() {
    parse_args "$@"
    
    trap cleanup EXIT ERR INT TERM
    
    echo ""
    log "=== Database Sync Tool for Symfony 8 ==="
    log "Engine: $DB_ENGINE | Source: $SOURCE_HOST:${SOURCE_PORT:-auto}"
    [[ "$USE_SSH_TUNNEL" == "true" ]] && log "SSH Tunnel: ${SSH_USER}@${SSH_HOST}"
    log "Target: Docker container '$DOCKER_CONTAINER'"
    echo ""
    
    validate_requirements
    
    # Set effective connection parameters
    if [[ "$USE_SSH_TUNNEL" == "true" ]]; then
        start_ssh_tunnel || exit 1
    else
        EFFECTIVE_HOST="$SOURCE_HOST"
        EFFECTIVE_PORT="$SOURCE_PORT"
    fi
    
    # Test connections
    test_source_connection || exit 1
    test_docker_connection || exit 1
    
    # Prepare target
    create_docker_database || exit 1
    
    # Run sync
    run_sync || exit 1
    
    # Generate entities if requested
    if [[ "$GENERATE_ENTITIES" == "true" ]]; then
        generate_entities
    fi
    
    echo ""
    log_success "=== All operations completed successfully ==="
}

main "$@"